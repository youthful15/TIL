# 데이터 구조



## 순서가 있는 데이터 구조



### 문자열 (String Type)

- immutable
- 모든 문자는 str타입. 작은 따옴표 혹은 큰 따옴표를 활용하여 표기.



### 문자열 조회 / 탐색 및 검증 메소드

| 문법        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| s.find(x)   | x의 첫 번째 위치를 반환. 없으면 -1을 반환                    |
| s.index(x)  | x의 첫 번째 위치를 반환. 없으면 오류 발생                    |
| s.isalpha() | 알파벳 문자 여부 * 단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함) |
| s.isuper()  | 대문자 여부                                                  |
| s.islower() | 소문자 여부                                                  |
| s.istitle() | 타이틀 형식 여부                                             |

- 범위 순서 : isdecimal < isdigit < isnumeric 



### 문자열 변경 메소드

| 문법                         | 설명                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| s.replace(old, new[,count])  | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환<br />count를 지정하면 해당 개수만큼 시행 |
| s.strip([chars])             | 공백이나 특정 문자를 제거<br />왼쪽을 제거하거나(lstrip) 오른쪽을 제거(rstrip도 가능) |
| s.split([chars])             | 공백이나 특정 문자를 기준으로 분리해서 리스트로 반환         |
| 'separator'.join([iterable]) | seperator을 사이사이에 넣어서 iterable한 개체를 합침         |
| s.capitalize()               | 가장 첫 번째 글자를 대문자로                                 |
| s.title()                    | '나 공백 이후를 대문자로                                     |
| s.upper()                    | 모두 대문자로                                                |
| s.lower()                    | 모두 소문자로                                                |
| s.swapcase()                 | 대소문자 변경                                                |



### 리스트

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형 (가변자료형)
- 항상 대괄호 형태로 출력된다. [1, 2, 3, 4, 5]



### 리스트 메소드

| 문법                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| L.append(x)            | 리스트 마지막에 항목 x를 추가                                |
| L.insert(i, x)         | 리스트 인덱스 i에 항목 x를 삽입                              |
| L.remove(x)            | 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거<br />항목이 존재하지 않을 경우, ValueError |
| L.pop()                | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거        |
| L.pop(i)               | 리스트의 인덱스 i에 있는 항목을 반환 후 제거                 |
| L.extend(m)            | 순회형 m의 모든 항목들의 리스트 끝에 추가 (+=과 같은 기능)<br />익스텐드로 문자열을 추가하고 싶으면 리스트의 형태로 추가해야 함 |
| L.index(x, start, end) | 리스트에 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환     |
| L.reverse              | 리스트를 거꾸로 정렬                                         |
| L.sort(...)            | 리스트를 정렬 (매개변수 이용 가능)                           |
| L.count(x)             | 리스트에서 항목 x가 몇 개 존재하는지 개수를 반환             |
| .clear()               | 모든 항목을 삭제함                                           |



### 튜플 관련 메소드

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형 (객체 변경 불가, 불변 immutable)

- 항상 소괄호 형태로 출력 (1, 2, 3, 4, 5)

- 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메소드만을 지원
- 리스트 메소드 중 항목을 변경하는 메소드들을 제외하고 대부분 동일



## 순서가 없는 데이터 구조



### 셋(Set)

- 순서 없이 0개 이상의 해시가능한 객체를 참조하는 자료형 (가변자료형 mutable)

| 문법           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| s.copy()       | 셋의 얕은 복사본을 반환                                      |
| s.add(x)       | 항목 x가 셋 s에 없다면 추가                                  |
| s.pop()        | 셋s에서 랜덤하게 항목을 반환하고 해당 항목을 제거<br />셋이 비어있을 경우 KeyError |
| s.remove(s)    | 항목 x를 셋 s에서 삭제<br />셋이 비어있을 경우 KeyError      |
| s.discard(x)   | 항목 x가 셋s에 있는 경우 항목 x를 셋s에서 삭제               |
| s.update(t)    | 셋 t에 있는 모든 항목 중 셋s에 없는 항목을 추가              |
| s.clear()      | 모든 항목을 제거                                             |
| s.isdisjoint() | 셋 s가 셋 t의 서로 같은 항목을 하나라도 가지지 않은 경우 True 반환 |
| s.issubset()   | 셋 s가 셋 t의 하위 셋인 경우, True 반환                      |
| s.issuperset() | 셋 s가 셋 t의 상위 셋인 경우, True 반환                      |



### 딕셔너리

- 순서 없이 키-값(key-value) 쌍으로 이뤄진 객체를 참조하는 자료형

| 문법          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| s.clear()     | 모든 항목을 제거                                             |
| d.copy()      | 딕셔너리 d의 얕은 복사본을 반환                              |
| d.keys()      | 딕셔너리 d의 모든 키를 담은 뷰를 반환                        |
| .d.values()   | 딕셔너리 d의 모든 값을 담은 뷰를 반환                        |
| d.items()     | 딕셔너리 d의 모든 키-값의 쌍을 담은 뷰를 반환                |
| d.get(k)      | 키 k의 값을 반환하는데 키 k가 딕셔너리 d에 없을 경우 None을 반환 |
| d.get(k, v)   | 키 k의 값을 반환하는데 키 k가 딕셔너리 d에 없을 경우 v를 반환 |
| d.pop(k)      | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데,<br />키 k가 딕셔너리 d에 없을 경우 KeyError를 발생 |
| d.pop(k, v)   | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데<br />키 k가 딕셔너리 d에 없을 경우 v를 반환 |
| d.update(...) | 딕셔너리 d의 값을 매핑하여 업데이트                          |



## 복사 방법



### 할당

- 대입 연산자 : 리스트 복사 확인하기 (같은 주소)

```python
original_list = [1, 2, 3]
copy_list = original_list
copy_list[0] = 'hello'
print(original_list, copy_list)

# ['hello', 2, 3] ['hello', 2, 3]
```



### 얕은 복사

- Slice 연산자를 활용해 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)

```python
a = [1, e, 3]
b = a[:]
print(a, b)
# [1, 2, 3] [1, 2, 3]
b[0] = 5
print(a, b)
# [1, 2, 3] [5, 2, 3]
```



- 주의사항 : 복사하는 리스트의 원소가 주소를 참조하는 경우

```python
a = [1, 2, ['a', 'b']]
b = a[:]
print(a, b)
# [1, 2, ['a', 'b']], [1, 2, ['a', 'b']]
b[2][0] = 0
print(a, b)
# [1, 2, [0 'b']], [1, 2, [0 'b']]
```



### 깊은 복사

```python
import copy
a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)
print(a, b)
# [1, 2, ['a', 'b']], [1, 2, ['a', 'b']]
b[2][0] = 0
print(a, b)
# [1, 2, ['a', 'b']], [1, 2, [0, 'b']]
```

